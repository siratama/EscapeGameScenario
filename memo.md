まとまっていない memo 

### framework 仕様

Event には Direction を必ずで設定する必要がある。
設定されているかどうかのエラーチェックは行える。
※ Item には Direction は設定する必要はない。

### クロスプラットフォーム

プラットフォームごとに処理が異なる点は主に以下

* 描画
* ユーザー操作
* サウンド再生

当ライブラリでは、上記のようなプラットフォーム固有の処理以外の箇所を ライブラリ・フレームワーク化

ゲームのフレームワーク化は大抵難しくあらゆる動作に対応しようとすると巨大なものになってくる(Unity等)
アドベンチャーゲームならばある程度のフレームワーク化が可能

### テスト

* 出力ターゲットがなんであれ、別のターゲット環境でテストが可能
	* JavaScript or Flash ターゲット出力だが neko ターゲットで簡単にテスト確認が行える、等
	* プラットフォーム固有の処理を行うクラスは、ダミーのテスト用のクラスに置き換える 等 多少工夫が必要
		* 本来クリック操作を待つ所を、必ずクリックされたものとして値を返却するメソッド内容に置き換える 等

---

## 概念

### Event

#### プロパティ

* enabled
	* その Event が実行可能対象であるかどうかを判定するプロパティ
	* true に設定される事で Reader からの検出が可能になる
		* 同 hitArea(Rectangle) 内に enabled == true の Event が複数検出される場合 Reader はエラーを投げる

/*
* endless
	* 実行が完了しない Event である事を示すプロパティ
	* 例えば、背景オブジェクトをクリックして「これは○○です。」といった、テキストのみを表示したい場合 true に設定する
	* enabled が true になることで「実行対象にはなるが実行完了は不可」という状態になる
*/

* completed
	* Event が実行完了したかどうかを示すプロパティ
	* enabled が false の状態の Event に対し、実行完了前なのか 実行完了後なのか、判定するためのプロパティ
		* enabled が true の状態の Event は、実行完了前である
	* 開発側は意識する必要はないため private
	
#### 図解
	
#### 設計未解決思想

ループイベント問題

例えば Ａ, Ｂ, Ｃ, Ｄ のイベントが存在し、以下のようにＣのイベント完了後に有効になるイベントはＡに設定したとする。

Ａ.enabledEventsAfterCompletion = [Ｂ];
Ｂ.enabledEventsAfterCompletion = [Ｃ];
Ｃ.enabledEventsAfterCompletion = [Ａ];

Ａ→Ｂ→Ｃ
↑←←←↓

イベントＤの完了条件は、イベントＡの完了とする。

Ｄ.requiredCompletionEvents = [Ａ];

ここで、Ｃが完了した時、以下の状況が発生する。

(1)Ｃ.complete();
↓
(2)Ａ.enable();
↓
(3)Ｄ.isCompletable() == false;

仮に、Ｄが(1)の前ですでにイベント完了状態(completed == true)だったとしても、
Ｄは再びイベントが完了できない状態(Ｄ.isCompletable() == false)になる。

この状況に何か問題は発生しないか？

requiredCompletionEvents 内の Event 全てが completed == true の時のみに、
自身が completed == true 状態になるので、
completed == true にも関わらず
isCompletable() == false はロジックエラーである？

そんなことはない？
「一度は完了したが、他のイベントの影響により 完了が不可な状況になった」という状況はありえる。
(completed ではなく completed once か？)

この状況で、描画側がどういう表示にするかは、描画処理側の対処次第、となりそう。
ループイベントでは この状況が発生する旨を マニュアル記述で留意させる。
芋づる式であらゆるイベントがこの状況になる可能性があるため、ループイベントの使用は注意が必要である。

---

### ゲームデータセーブ

#### save
発火された Event.id を記録する

#### read
記録された Event.id から、Event と Direction.fired の取得を行い
はじめに発火した Event から 最後に発火された Event まで全て再発火処理を行う。

/*
#### 画面切り替えを一瞬で行うために ActionInterface.playDirect メソッドにも処理を記述する必要あり

Event 発火に伴い、画面の描画の変更が行われる場合があるとする
例)
* [りんご]を取ったら[空の皿]に表示が切り替わった
* シーン1用画面[家の中]からシーン2用画面[城の中]に表示が切り替わった

画面描画変更は ActionInterface を利用したクラス(Action クラス等)で必ず行う必要がある。
ActionInterface を利用したクラス内で、フェードアウト等、徐々に画面が切り替わる場合等があるが
ゲームデータ読み込み時、その徐々に画面が切り替わる様を再現するのは無駄なので、
ActionInterface.playDirect メソッドを実行する事で[ActionInterface を利用したクラス実行後の表示]になるような処理を記述する必要がある。

ActionInterface.playDirect メソッドは、セーブデータだけではなく
ユーザがゲーム中に演出を飛ばしたい場合にも利用できる
*/
